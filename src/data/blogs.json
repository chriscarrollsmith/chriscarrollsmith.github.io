[
  {
    "id": 3,
    "title": "Returning the last evaluated operand: A fun Python quirk!",
    "date": "2024-09-13",
    "content": "<p>Unlike some languages where logical operators always return <code class='inline'>True</code> or <code class='inline'>False</code>, Python's 'and' returns the last evaluated operand. Usually this doesn't change code behavior all that much, because if we're expecting a boolean return value, any truthy return value is still going to evaluate as truthy and trigger whatever logic <code class='inline'>True</code> would have. However, it might trip you up if you're doing strict type checking with mypy and expect your return value to be boolean.</p><p>Normally no one uses this much in production code, because it's not very readable, but it can be a fun and surprising trick for impressing people with your 'code golf' skills (solving problems with the smallest possible number of characters). For instance, check out this simple function to return the text of a tweet only if it's less than 140 characters, and otherwise to return <code class='inline'>False</code>. Most people would expect this function call to print <code class='inline'>True</code>!</p><pre><code>tweet_it = lambda s: len(s) <= 140 and s\n\nprint(tweet_it('Hello world!')) # Not a bool!</code></pre><pre><samp>Hello world!</samp></pre><p>This behavior is much more intuitive with the <code class='inline'>or</code> operator, which works the same way. We can use this behavior to return a variable only if it's truthy, and otherwise to return something else (like a default return value, <code class='inline'>False</code>, or <code class='inline'>-1</code>):</p><pre><code>def non_empty_string(s) -> str:\n  '''Return the string if it's non-empty; else return a default non-empty string'''\n  return s or 'default return value'\n\nprint(non_empty_string('valid string'))\nprint(non_empty_string(''))</code></pre><pre><samp>valid string\ndefault return value</samp></pre><p>Since we've used a logical operator in the <code class='inline'>return</code> statement of the <code class='inline'>non_empty_string</code> function, you might expect the function to return a boolean. In fact, since 'default return value' is truthy, you'd think the function would always return <code class='inline'>True</code>! But that's not how logical tests in Python work.</p><p>Instead, the logical test returns the last evaluated operand. If <code class='inline'>s</code> evaluates as truthy, then the logical test stops there and returns <code class='inline'>s</code>. Otherwise, it returns the next operand: 'default return value'.</p><p>Once you get the hang of it, this behavior makes it really easy and intuitive to always return some fallback value if your calculated return value is falsy. Note that the fallback value will always be returned from the function, regardless of whether it's truthy or falsy. Our 'default return value' is truthy, but we could just as easily have returned a falsy value like <code class='inline'>0</code> or <code class='inline'>[]</code> by placing it after the <code class='inline'>or</code>.</p>",
    "excerpt": "Discover a unique Python quirk: logical operators returning the last evaluated operand. Learn how this behavior affects code execution, enables clever 'code golf' tricks, and provides intuitive ways to handle default values. Explore examples with 'and' and 'or' operators that might surprise even experienced Python developers.",
    "image": "images/Python.png"
  },
  {
    "id": 2,
    "title": "Understanding the mutable default argument problem in Python",
    "date": "2024-09-24",
    "content": "<p>Almost everyone who learns Python gets burned at some point by this little quirk. Imagine you're writing a function <code class=\"inline\">append_to</code> that appends an element <code class=\"inline\">e</code> to a list <code class=\"inline\">l</code>, with <code class=\"inline\">l</code> as an optional argument and an empty list as the default. You might be tempted to initialize the default empty list in the function signature. We would expect calling <code class=\"inline\">append_to(1)</code> to always return <code class=\"inline\">[1]</code>, right? But look what happens when we call it twice:</p><pre><code>def append_to(e, l=[]):\n    l.append(e)\n    return l\n\nprint(append_to(1))\nprint(append_to(2))</code></pre><pre><samp>[1]\n[1, 2]</samp></pre><p>However, notice that this is not what happens with \"immutable\" data types like <code class=\"inline\">int</code> or <code class=\"inline\">str</code>. If we initialize these variables to default values and then modify them inside the function, they get reset to the default the next time the function is called:</p><pre><code>def multiply_it(x, y = 1):\n    y = x * y\n    return y\n\nprint(multiply_it(2))\nprint(multiply_it(2))</code></pre><pre><samp>2\n2</samp></pre><p>So why is the behavior different? Well, there are a couple important things to understand here.</p><p>First, Python has \"mutable\" objects (e.g., lists, dicts, sets) and \"immutable\" ones (e.g., ints, strings), and the two categories of objects behave differently when passed to a function.</p><p>For memory efficiency, Python typically only stores one copy of any immutable object. Variables with the same immutable value will almost always point to the same location in memory. For example, if <code class=\"inline\">a</code> and <code class=\"inline\">b</code> both equal <code class=\"inline\">1</code>, they will have the same <code class=\"inline\">id</code>. If I change the value of one of these variables (e.g., <code class=\"inline\">a += 1</code>), I'm not actually modifying the object it pointed to; that object is immutable and cannot be changed. Rather, I'm telling the variable that it now points to a new/different immutable object at a different memory address.</p><pre><code>print(f\"id of the integer '1': {id(1)}\")\n\na = 1\n\nprint(f\"id of 'a' in parent scope: {id(a)}\")\n\ndef a_func(a, b = 1):\n    print(f\"id of 'a' in function scope: {id(a)}\")\n    print(f\"id of 'b' in function scope: {id(b)}\")\n\na_func(a)\n\na += 1\n\nprint(f\"id of 'a' after incrementing: {id(a)}\")</code></pre><pre><samp>id of the integer '1': 140736354896312\nid of 'a' in parent scope: 140736354896312\nid of 'a' in function scope: 140736354896312\nid of 'b' in function scope: 140736354896312\nid of 'a' after incrementing: 140736354896344</samp></pre><p>Mutable objects are more complicated, however. Since these mutable objects might be very large, Python generally prefers to change them \"in place\"—by tweaking the object at the original memory address—rather than by creating an entire new modified copy of the object at a new address, as we would with an immutable object. For the same reason, Python's default behavior is to pass them \"by reference\" in assignment operations, function calls, and function return statements. In other words, a variable passed to the function from the parent scope, the variable inside the function, and the variable returned from the function will all point to the same object in memory. A consequence of this handling of mutable objects is that in-place changes made to a mutable object inside a function also affect the object in the parent scope (since they both point to the same memory address).</p><pre><code>a = [1]\n\nprint(f\"Value of 'a' in parent scope: {a}\")\n\ndef append_to(e, l):\n    l.append(e)\n\nappend_to(2, a)\n\nprint(f\"Value of 'a' in parent scope after in-place 'append' inside function: {a}\")</code></pre><pre><samp>Value of 'a' in parent scope: [1]\nValue of 'a' in parent scope after in-place 'append' inside function: [1, 2]</samp></pre><p>The second thing that needs to be understood in order to grasp the weird behavior of mutable default arguments is exactly when, how, and where the default value is constructed.</p><p>When: Any code in the function signature's default arguments is evaluated when the function is initialized, not every time it's run.</p><p>How: When you execute the code to create a function, the function is created as an object, and its default values are bound to the object (under its <code class=\"inline\">__defaults__</code> attribute).</p><p>Where: This means that, just like any other mutable object you might pass to the function, the default mutable object exists in the parent scope, and any in-place modifications of the object inside the function will also change it persistently in the parent scope.</p><pre><code>def append_to(e, l = []):\n    l.append(e)\n    print(\"Inside function:\")\n    print(f\"- Value of 'l' after append: {l}\")\n    print(f\"- id of 'l' after append: {id(l)}\")\n\nprint(\"In parent scope before calling function:\")\nprint(f\"- Default value of 'l' bound to function object: {append_to.__defaults__[0]}\")\nprint(f\"- id of default value of 'l' bound to function object: {id(append_to.__defaults__[0])}\")\n\nappend_to(1)\n\nprint(\"In parent scope after calling function:\")\nprint(f\"- Default value of 'l' bound to function object: {append_to.__defaults__[0]}\")\nprint(f\"- id of default value of 'l' bound to function object: {id(append_to.__defaults__[0])}\")</code></pre><pre><samp>In parent scope before calling function:\n- Default value of 'l' bound to function object: []\n- id of default value of 'l' bound to function object: 2423913173504\nInside function:\n- Value of 'l' after append: [1]\n- id of 'l' after append: 2423913173504\nIn parent scope after calling function:\n- Default value of 'l' bound to function object: [1]\n- id of default value of 'l' bound to function object: 2423913173504</samp></pre><p>How, then, should we handle the case where we want an optional argument that initializes a new empty mutable object every time a user calls the function without specifying an input for the argument? The standard approach is to make the default value <code class=\"inline\">None</code>, and then initialize an empty object inside the function body if the argument is <code class=\"inline\">None</code>.</p><pre><code>def append_to(e, l = None):\n    if l is None:\n        l = []\n    l.append(e)\n    print(f\"id of 'l' inside function: {id(l)}\")\n    return l\n\nl = append_to(1)\nprint(f\"id of 'l' returned from function: {id(l)}\")</code></pre><pre><samp>id of 'l' inside function: 2423912764096\nid of 'l' returned from function: 2423912764096</samp></pre><p>Note, however, that we usually return <code class=\"inline\">None</code> from a function that modifies a mutable object \"in place\" (to avoid implying that it returns a copy), but we have to break that pattern in the above workaround. Returning the object from the function is perfectly valid, but it's considered bad style.</p><p>The more idiomatic (a.k.a Pythonic) solution would be to make the mutable argument non-optional (i.e., supply no default value) and require users to initialize an empty mutable object in the calling context and pass it to the function.</p><pre><code>l = []\n\ndef append_to(e, l):\n    l.append(e)\n\nappend_to(1, l)\nprint(l)</code></pre><pre><samp>[1]</samp></pre><p>Your other option is to avoid doing \"in-place\" operations on the mutable default argument and instead copy it, then modify and return the copy. There are lots of ways to do this. Mutable objects generally have a <code class=\"inline\">.copy()</code> method that will return a copy rather than a reference to the object. Or you can append to a list with the <code class=\"inline\">+</code> operator, slice a list with <code class=\"inline\">[:]</code>, or use any other method or operator that returns a copy instead of modifying in place. Just keep in mind that this can be quite computationally expensive if the object you're copying is really big.</p><pre><code>def appended_to(e, l = []):\n    new_l = l.copy()\n    new_l.append(e)\n    return new_l\n\nprint(appended_to(1))\nprint(appended_to(2))</code></pre><pre><samp>[1]\n[2]</samp></pre>",
    "excerpt": "Learn how to avoid the mutable default argument problem in Python and how to properly initialize mutable objects as default arguments. Understand the behavior of mutable and immutable objects and how they affect your code.",
    "image": "images/Python.png"
  },
  {
    "id": 1,
    "title": "How XOR Encryption Works",
    "date": "2024-08-15",
    "content": "<style>.container{margin-top:1rem;background-color:white;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,0.1);overflow:hidden}.operation-selector{display:flex;justify-content:space-around;padding:15px;background-color:#4a4a4a}.operation-btn{padding:10px 20px;border:none;background-color:#6a6a6a;color:white;cursor:pointer;transition:background-color 0.3s}.operation-btn.active{background-color:#2a2a2a}table{width:100%;border-collapse:collapse}th,td{padding:12px;text-align:center;border-bottom:1px solid #e0e0e0;width:20%}th{background-color:#f5f5f5;font-weight:bold}.operator,.result{font-weight:bold}.balance-info{padding:15px;background-color:#fafafa;border-top:1px solid #e0e0e0}.probability{display:inline-block;margin-right:20px}#balance-description{color:#333;font-weight:500}</style><p>XOR is a logical operator that returns True (or 1) if two values are different, and False (or 0) if they're the same. Contrast AND, which returns True (1) only if both values are True (1), and OR, which returns True (1) if either value is True (1).</p><p>XOR has an interesting property that makes it useful for encryption. Given some binary input string and some randomly generated binary encryption key, using the XOR operator to map each input digit to the corresponding key digit will produce 'perfectly balanced' output. That is, an input 0 will be encoded as 1 exactly half of the time, and as 0 the other half of the time. Since the encoding is a simple, parallelizable logical operation, it can be executed <em>very</em> fast.</p><p>In contrast, using the AND and OR operators produces biased output, as illustrated in the interactive table below. AND <em>always</em> encodes a 0 input as 0. Similarly, OR <em>always</em> encodes a 1 as 1. That means these operators would leak half the input data, making it relatively trivial to reconstruct the rest. XOR, however, doesn't leak any information. If the key is as long as the input data and the key is never re-used, XOR encryption is theoretically unbreakable. Click the buttons at the top of the interactive table to toggle between operators and see for yourself how each works.</p><div class=\"container\"><div class=\"operation-selector\"><button class=\"operation-btn\" data-op=\"AND\">AND</button><button class=\"operation-btn\" data-op=\"OR\">OR</button><button class=\"operation-btn active\" data-op=\"XOR\">XOR</button></div><table><tr><th>Plaintext</th><th></th><th>Key</th><th></th><th>Ciphertext</th></tr><tr><td>0</td><td class=\"operator\">XOR</td><td>0</td><td>=</td><td class=\"result\">0</td></tr><tr><td>0</td><td class=\"operator\">XOR</td><td>1</td><td>=</td><td class=\"result\">1</td></tr><tr><td>1</td><td class=\"operator\">XOR</td><td>0</td><td>=</td><td class=\"result\">1</td></tr><tr><td>1</td><td class=\"operator\">XOR</td><td>1</td><td>=</td><td class=\"result\">0</td></tr></table><div class=\"balance-info\"><span class=\"probability\">Probability of 0: <span id=\"prob0\">50</span>%</span><span class=\"probability\">Probability of 1: <span id=\"prob1\">50</span>%</span><p id=\"balance-description\">Balance: Perfectly balanced. Equal 0s and 1s, regardless of input.</p></div></div><p>In practice, of course, these conditions are rarely met. XOR encryption in the real world typically uses a repeating key, and/or the key is reused over multiple inputs. That's why XOR is considered a fairly weak encryption algorithm and is not used very much. But under ideal conditions, XOR encryption is a fast and powerful thing.</p>",
    "script": "(function() { const operations = { XOR: { op: (a, b) => a ^ b, description: 'Perfectly balanced. Equal 0s and 1s, regardless of input.' }, AND: { op: (a, b) => a & b, description: 'Imbalanced, biased towards 0. May leak input information.' }, OR: { op: (a, b) => a | b, description: 'Imbalanced, biased towards 1. May leak input information.' } }; function updateTable(operation) { const operatorCells = document.querySelectorAll('.operator'); const resultCells = document.querySelectorAll('.result'); let count0 = 0; let count1 = 0; operatorCells.forEach(cell => cell.textContent = operation); resultCells.forEach((cell, index) => { const a = Math.floor(index / 2); const b = index % 2; const result = operations[operation].op(a, b); cell.textContent = result; result === 0 ? count0++ : count1++; }); document.getElementById('prob0').textContent = count0 * 25; document.getElementById('prob1').textContent = count1 * 25; document.getElementById('balance-description').textContent = 'Balance: ' + operations[operation].description; } document.querySelectorAll('.operation-btn').forEach(btn => { btn.addEventListener('click', function() { document.querySelector('.operation-btn.active').classList.remove('active'); this.classList.add('active'); updateTable(this.dataset.op); }); }); updateTable('XOR'); })()",
    "excerpt": "Explore the fascinating world of XOR encryption! Learn how this simple logical operator creates perfectly balanced output, making it a powerful tool for secure data encryption. Discover why XOR outperforms AND and OR in cryptography, and experiment with an interactive demonstration to see these operators in action.",
    "image": "images/Python.png"
  }
]