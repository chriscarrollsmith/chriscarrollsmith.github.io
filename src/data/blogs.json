[
  {
    "id": 1,
    "title": "How XOR Encryption Works",
    "date": "2024-08-15",
    "content": "<style>.container{margin-top:1rem;background-color:white;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,0.1);overflow:hidden}.operation-selector{display:flex;justify-content:space-around;padding:15px;background-color:#4a4a4a}.operation-btn{padding:10px 20px;border:none;background-color:#6a6a6a;color:white;cursor:pointer;transition:background-color 0.3s}.operation-btn.active{background-color:#2a2a2a}table{width:100%;border-collapse:collapse}th,td{padding:12px;text-align:center;border-bottom:1px solid #e0e0e0;width:20%}th{background-color:#f5f5f5;font-weight:bold}.operator,.result{font-weight:bold}.balance-info{padding:15px;background-color:#fafafa;border-top:1px solid #e0e0e0}.probability{display:inline-block;margin-right:20px}#balance-description{color:#333;font-weight:500}</style><p>XOR is a logical operator that returns True (or 1) if two values are different, and False (or 0) if they're the same. Contrast AND, which returns True (1) only if both values are True (1), and OR, which returns True (1) if either value is True (1).</p><p>XOR has an interesting property that makes it useful for encryption. Given some binary input string and some randomly generated binary encryption key, using the XOR operator to map each input digit to the corresponding key digit will produce 'perfectly balanced' output. That is, an input 0 will be encoded as 1 exactly half of the time, and as 0 the other half of the time. Since the encoding is a simple, parallelizable logical operation, it can be executed <em>very</em> fast.</p><p>In contrast, using the AND and OR operators produces biased output, as illustrated in the interactive table below. AND <em>always</em> encodes a 0 input as 0. Similarly, OR <em>always</em> encodes a 1 as 1. That means these operators would leak half the input data, making it relatively trivial to reconstruct the rest. XOR, however, doesn't leak any information. If the key is as long as the input data and the key is never re-used, XOR encryption is theoretically unbreakable. Play with the interactive table to see for yourself how this works.</p><div class=\"container\"><div class=\"operation-selector\"><button class=\"operation-btn\" data-op=\"AND\">AND</button><button class=\"operation-btn\" data-op=\"OR\">OR</button><button class=\"operation-btn active\" data-op=\"XOR\">XOR</button></div><table><tr><th>Plaintext</th><th></th><th>Key</th><th></th><th>Ciphertext</th></tr><tr><td>0</td><td class=\"operator\">XOR</td><td>0</td><td>=</td><td class=\"result\">0</td></tr><tr><td>0</td><td class=\"operator\">XOR</td><td>1</td><td>=</td><td class=\"result\">1</td></tr><tr><td>1</td><td class=\"operator\">XOR</td><td>0</td><td>=</td><td class=\"result\">1</td></tr><tr><td>1</td><td class=\"operator\">XOR</td><td>1</td><td>=</td><td class=\"result\">0</td></tr></table><div class=\"balance-info\"><span class=\"probability\">Probability of 0: <span id=\"prob0\">50</span>%</span><span class=\"probability\">Probability of 1: <span id=\"prob1\">50</span>%</span><p id=\"balance-description\">Balance: Perfectly balanced. Equal 0s and 1s, regardless of input.</p></div></div><p>In practice, of course, these conditions are rarely met. XOR encryption in the real world typically uses a repeating key, and/or the key is reused over multiple inputs. That's why XOR is considered a fairly weak encryption algorithm and is not used very much. But under ideal conditions, XOR encryption is a fast and powerful thing.</p>",
    "script": "(function() { const operations = { XOR: { op: (a, b) => a ^ b, description: 'Perfectly balanced. Equal 0s and 1s, regardless of input.' }, AND: { op: (a, b) => a & b, description: 'Imbalanced, biased towards 0. May leak input information.' }, OR: { op: (a, b) => a | b, description: 'Imbalanced, biased towards 1. May leak input information.' } }; function updateTable(operation) { const operatorCells = document.querySelectorAll('.operator'); const resultCells = document.querySelectorAll('.result'); let count0 = 0; let count1 = 0; operatorCells.forEach(cell => cell.textContent = operation); resultCells.forEach((cell, index) => { const a = Math.floor(index / 2); const b = index % 2; const result = operations[operation].op(a, b); cell.textContent = result; result === 0 ? count0++ : count1++; }); document.getElementById('prob0').textContent = count0 * 25; document.getElementById('prob1').textContent = count1 * 25; document.getElementById('balance-description').textContent = 'Balance: ' + operations[operation].description; } document.querySelectorAll('.operation-btn').forEach(btn => { btn.addEventListener('click', function() { document.querySelector('.operation-btn.active').classList.remove('active'); this.classList.add('active'); updateTable(this.dataset.op); }); }); updateTable('XOR'); })()"
  }
]